class Solution {
    public int maxProduct(int[] nums) {
        // Edge case: array has at least one element by constraints
        int n = nums.length;
        
        int curMax = nums[0];
        int curMin = nums[0];
        int result = nums[0];
        
        for (int i = 1; i < n; i++) {
            int num = nums[i];
            
            // If current number is negative, swap curMax and curMin
            // because multiplying by a negative flips signs.
            if (num < 0) {
                int temp = curMax;
                curMax = curMin;
                curMin = temp;
            }
            
            // Either start fresh from num or extend the previous product
            curMax = Math.max(num, curMax * num);
            curMin = Math.min(num, curMin * num);
            
            // Update result
            result = Math.max(result, curMax);
        }
        
        return result;
    }
}
